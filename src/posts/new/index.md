---
title: new!
path: /new
date: 2019-01-29
---


## 何について書いたか
フロントエンド開発でもアルゴリズムと計算量の知識が活きたよという話

よくある見出し一覧を作る時に考えたことです。  
見出しの大きさによってネストしていきます。これは根付き木の構造をしていると見れます。
例えば画像のような見出しリストは、画像の木で表現できます。

さて、このBlogはGatsbyで構築しており、MarkdownファイルからHTMLにデータ変換し記事ページを作成します。
gatsby-remark-autolink-headers というプラグインで、データ変換時に見出し(h1~h4タグ)にアンカーリンク用のidを付与し、見出しの一覧を取得できます。
リストは、idと深さを持ったオブジェクトになります。{ value: string, depth: number }[]

この問題はこのように言い換えられます。
深さ情報を持ったノードのリストが与えらるので、階層構造に変換してください。
ただし、任意の子ノードの親ノードは常に前にきます。

つまりこのようにしたいわけです。

```javascript
// comment
input = [{ depth: 1 }, { depth: 2 }, { depth: 3 }]

ecport default 
expect_output = [
    {
        depth: 1,
        children: [
            {
                depth: 2,
                childrent: []
            }
        ]
    },
    {
        depth: 1,
        children: [
            {
                depth: 2,
                childrent: []
            }
        ]
    }
]
```

ぱっと思いつくのは順番に各ノードの親を調べる方法です。
また、配列の末端は必ず葉となるので、末端から先端へと調べて行けば良さそうです。
選んだノードから先端までの配列を線形探索し、親を探します。
O(n)の処理をn回行うので、このアルゴリズムの計算量はO(n^2)となるはずです。

ソート済でノードの位置関係を無視してよいのなら、バイナリサーチを使えばO(nlogn)になりますが今回のケースは違いますし、O(n)も無理そうです。
ということでこのコードは妥当かなと判断できるわけです。



このアルゴリズムの計算量がO(n^2)となる理由を買いてみます。
i = 5 のとき 4回
i = 4のとき 3回
i = 3のとき 2回

...

i = n のとき n-1回
i = n-(n-1)  のとき 1回
i = n　のとき 0回

初項 n-1，公差 -1，項数 n の初項から第 n 項　までの話で計算量がもとまりマス。
合計で1/2n^2 -1/2n回ループが回るので、最高次以外と係数を無視してO(n^2)となるわけです。





IMO
読みやすいか、といったイディオムばかりを意識していましたが、
計算量を優先するか、読みやすさを優先するかは場合によると思います。
またわざわざこの構造体にしなければ良いだけの話です。
